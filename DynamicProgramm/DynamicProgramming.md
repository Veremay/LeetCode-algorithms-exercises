# 基础

**动规五部曲：**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

如果代码写出来了，一直AC不了，灵魂三问：

1. 这道题目我举例推导状态转移公式了么？
2. 我打印dp数组的日志了么？
3. 打印出来了dp数组和我想的一样么？

# 70. 爬楼梯 (climbStairs)

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。

那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。

所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。

五部曲开始

1.  确定dp数组以及下标的含义

    dp`[i]`： 爬到第`i`层楼梯，有`dp[i]`种方法

2. 确定递推公式

    如何可以推出`dp[i]`呢？

    从`dp[i]`的定义可以看出，`dp[i]` 可以有两个方向推出来。

    首先是`dp[i - 1]`，上`i-1`层楼梯，有`dp[i - 1]`种方法，那么再一步跳一个台阶不就是`dp[i]`了么。

    还有就是`dp[i - 2]`，上`i-2`层楼梯，有`dp[i - 2]`种方法，那么再一步跳两个台阶不就是`dp[i]`了么。

    那么`dp[i]`就是 `dp[i - 1]`与`dp[i - 2]`之和！

    所以`dp[i] = dp[i - 1] + dp[i - 2]` 。

3. dp数组如何初始化

    再回顾一下`dp[i]`的定义：爬到第`i`层楼梯，有`dp[i]`种方法。

    那么i为0，dp[i]应该是多少

    好像是有争议的。

    不考虑`dp[0]`如何初始化，只初始化`dp[1] = 1`，`dp[2] = 2`，然后从i = 3开始递推，这样才符合`dp[i]`的定义。

4. 确定遍历顺序

    从递推公式`dp[i] = dp[i - 1] + dp[i - 2]`;中可以看出，遍历顺序一定是从前向后遍历的

5. 举例推导dp数组

    ![img.png](climbStairs.png)


时间复杂度：$O(n)$

空间复杂度：$O(n)$

# 746. 使用最小花费爬楼梯 (minCostClimbingStairs)

1. 确定dp数组以及下标的含义

    dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。

2. 确定递推公式
   
    可以有两个途径得到`dp[i]`，一个是`dp[i-1]` 一个是`dp[i-2]`。

    `dp[i - 1]` 跳到 `dp[i]` 需要花费 `dp[i - 1] + cost[i - 1]`。
    
    `dp[i - 2]` 跳到 `dp[i]` 需要花费 `dp[i - 2] + cost[i - 2]`。
    
    那么究竟是选从`dp[i - 1]`跳还是从`dp[i - 2]`跳呢？
    
    一定是选最小的，所以`dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`;

3. dp数组如何初始化

    只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]和dp[1]推出

4. 确定遍历顺序

   `dp[i]`由`dp[i-1]` `dp[i-2]`推出，所以是从前到后遍历`cost`数组就可以了。

5. 举例推导dp数组

    ![img.png](minCostClimbingStairs.png)

时间复杂度：$O(n)$

空间复杂度：$O(n)$

# 62.不同路径 (uniquePaths)

这道题最直观看上去就是用图论里的深度优先搜索dfs，也确实是个解题思路。

但这里先看动规吧。

机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。

按照动规五部曲来分析：

1. 确定dp数组（dp table）以及下标的含义

    dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

2. 确定递推公式

    想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。

    此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。

    那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。

3. dp数组的初始化

    如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。

    所以初始化代码为：

    ```java
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int j = 0; j < n; j++) dp[0][j] = 1;
    ```

4. 确定遍历顺序

    这里要看一下递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。

    这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。

5. 举例推导dp数组

    ![img.png](uniquePaths.png)

# 63. 不同路径 II (uniquePathsWithObstacles)

**注意！！**

从(0,0)开始，如果没有障碍物则设为1，一旦遇到障碍物，后面的全部设为0

# 343. 整数拆分 (integerBreak)

1. 确定dp数组（dp table）以及下标的含义

   dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
   
   dp[i]的定义将贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！

2. 确定递推公式

   可以想 dp[i]最大乘积是怎么得到的呢？
   
   其实可以从1遍历j，然后有两种渠道得到dp[i].
   
   一个是j * (i - j) 直接相乘。
   
   一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。
   
   那有同学问了，j怎么就不拆分呢？
   
   j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
   
   也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。

   对于较小的数，拆分的乘积反而小于不拆分的原数。

   递推公式传入的取最大值的三个值的含义分别是：

   1. 历史最优（dp[i]）：保存当前找到的最佳结果。因为对于每个 i，我们要尝试多种拆分方式（多个 j 值），取其中最大值，所以需要保存下来，以便跟下一个拆分版本作比较。

   2. 拆成两部分（(i-j)×j）：最简单的拆分。当剩余部分较小的时候，拆分的乘积反而小于不拆分的原数。

   3. 拆成多部分（j×dp[i-j]）：第一个数不拆，后面的继续拆

3. dp的初始化

   严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。

   这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1

4. 确定遍历顺序

   确定遍历顺序，先来看看递归公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))`;

   dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。

   所以遍历顺序为：

   ```java
   for (int i = 3; i <= n ; i++) {
    for (int j = 1; j < i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
   }
   ```

   注意 枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了。

5. 举例推导dp数组

# 96.不同的二叉搜索树 (numTrees)

![img.png](numTreesn=2.png)

![img.png](numTrees.png)

因为这道题只考虑数目，所以当1为头结点的时候，其右子树有两个节点，这两个节点的布局和 n 为2的时候两棵树的布局是一样的。

1. 确定dp数组（dp table）以及下标的含义

   dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。

2. 确定递推公式

   在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
   
   j相当于是头结点的元素，从1遍历到i为止。

3. dp数组如何初始化
   
   初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

4. 确定遍历顺序
   
   首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

   那么遍历i里面每一个数作为头结点的状态，用j来遍历。