# 基础

**动规五部曲：**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

如果代码写出来了，一直AC不了，灵魂三问：

1. 这道题目我举例推导状态转移公式了么？
2. 我打印dp数组的日志了么？
3. 打印出来了dp数组和我想的一样么？

# 70. 爬楼梯 (climbStairs)

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。

那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。

所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。

五部曲开始

1.  确定dp数组以及下标的含义

    dp`[i]`： 爬到第`i`层楼梯，有`dp[i]`种方法

2. 确定递推公式

    如何可以推出`dp[i]`呢？

    从`dp[i]`的定义可以看出，`dp[i]` 可以有两个方向推出来。

    首先是`dp[i - 1]`，上`i-1`层楼梯，有`dp[i - 1]`种方法，那么再一步跳一个台阶不就是`dp[i]`了么。

    还有就是`dp[i - 2]`，上`i-2`层楼梯，有`dp[i - 2]`种方法，那么再一步跳两个台阶不就是`dp[i]`了么。

    那么`dp[i]`就是 `dp[i - 1]`与`dp[i - 2]`之和！

    所以`dp[i] = dp[i - 1] + dp[i - 2]` 。

3. dp数组如何初始化

    再回顾一下`dp[i]`的定义：爬到第`i`层楼梯，有`dp[i]`种方法。

    那么i为0，dp[i]应该是多少

    好像是有争议的。

    不考虑`dp[0]`如何初始化，只初始化`dp[1] = 1`，`dp[2] = 2`，然后从i = 3开始递推，这样才符合`dp[i]`的定义。

4. 确定遍历顺序

    从递推公式`dp[i] = dp[i - 1] + dp[i - 2]`;中可以看出，遍历顺序一定是从前向后遍历的

5. 举例推导dp数组

    ![img.png](climbStairs.png)


时间复杂度：$O(n)$

空间复杂度：$O(n)$

# 746. 使用最小花费爬楼梯 (minCostClimbingStairs)

1. 确定dp数组以及下标的含义

    dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。

2. 确定递推公式
   
    可以有两个途径得到`dp[i]`，一个是`dp[i-1]` 一个是`dp[i-2]`。

    `dp[i - 1]` 跳到 `dp[i]` 需要花费 `dp[i - 1] + cost[i - 1]`。
    
    `dp[i - 2]` 跳到 `dp[i]` 需要花费 `dp[i - 2] + cost[i - 2]`。
    
    那么究竟是选从`dp[i - 1]`跳还是从`dp[i - 2]`跳呢？
    
    一定是选最小的，所以`dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`;

3. dp数组如何初始化

    只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]和dp[1]推出

4. 确定遍历顺序

   `dp[i]`由`dp[i-1]` `dp[i-2]`推出，所以是从前到后遍历`cost`数组就可以了。

5. 举例推导dp数组

    ![img.png](minCostClimbingStairs.png)

时间复杂度：$O(n)$

空间复杂度：$O(n)$

# 62.不同路径 (uniquePaths)

这道题最直观看上去就是用图论里的深度优先搜索dfs，也确实是个解题思路。

但这里先看动规吧。

机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。

按照动规五部曲来分析：

1. 确定dp数组（dp table）以及下标的含义

    dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

2. 确定递推公式

    想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。

    此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。

    那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。

3. dp数组的初始化

    如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。

    所以初始化代码为：

    ```java
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int j = 0; j < n; j++) dp[0][j] = 1;
    ```

4. 确定遍历顺序

    这里要看一下递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。

    这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。

5. 举例推导dp数组

    ![img.png](uniquePaths.png)

# 63. 不同路径 II (uniquePathsWithObstacles)

**注意！！**

从(0,0)开始，如果没有障碍物则设为1，一旦遇到障碍物，后面的全部设为0

# 343. 整数拆分 (integerBreak)

1. 确定dp数组（dp table）以及下标的含义

   dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
   
   dp[i]的定义将贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！

2. 确定递推公式

   可以想 dp[i]最大乘积是怎么得到的呢？
   
   其实可以从1遍历j，然后有两种渠道得到dp[i].
   
   一个是j * (i - j) 直接相乘。
   
   一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。
   
   那有同学问了，j怎么就不拆分呢？
   
   j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
   
   也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。

   对于较小的数，拆分的乘积反而小于不拆分的原数。

   递推公式传入的取最大值的三个值的含义分别是：

   1. 历史最优（dp[i]）：保存当前找到的最佳结果。因为对于每个 i，我们要尝试多种拆分方式（多个 j 值），取其中最大值，所以需要保存下来，以便跟下一个拆分版本作比较。

   2. 拆成两部分（(i-j)×j）：最简单的拆分。当剩余部分较小的时候，拆分的乘积反而小于不拆分的原数。

   3. 拆成多部分（j×dp[i-j]）：第一个数不拆，后面的继续拆

3. dp的初始化

   严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。

   这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1

4. 确定遍历顺序

   确定遍历顺序，先来看看递归公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))`;

   dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。

   所以遍历顺序为：

   ```java
   for (int i = 3; i <= n ; i++) {
    for (int j = 1; j < i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
   }
   ```

   注意 枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了。

5. 举例推导dp数组

# 96.不同的二叉搜索树 (numTrees)

![img.png](numTreesn=2.png)

![img.png](numTrees.png)

因为这道题只考虑数目，所以当1为头结点的时候，其右子树有两个节点，这两个节点的布局和 n 为2的时候两棵树的布局是一样的。

1. 确定dp数组（dp table）以及下标的含义

   dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。

2. 确定递推公式

   在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
   
   j相当于是头结点的元素，从1遍历到i为止。

3. dp数组如何初始化
   
   初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

4. 确定遍历顺序
   
   首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

   那么遍历i里面每一个数作为头结点的状态，用j来遍历。

# 背包问题

![img.png](背包问题概览.png)

## 0/1背包问题
| 物品名 | 重量 | 价值 |
|-----|----|----|
| 物品0 | 1  | 15 |
| 物品1 | 3  | 20 |
| 物品2 | 4  | 30 |

背包最大的容量是4

**一定要搞清楚`dp[i][j]`数组的含义！**

dp数组含义是：从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少。

动态规划的思路是根据子问题的求解推导出整体的最优解。

先看把物品0 放入背包的情况：

![img.png](背包问题表格1.png)

![img.png](背包问题表格2.png)

再来递推公式。

`物品i`有两种状态：放和不放。

如果背包里不放`物品i`，那么最大价值为`dp[i-1][j]`；

如果放`物品i`，那么最大价值就是`不放物品i的最大价值+物品i的价值`，即`dp[i-1][j-weight[i]] + value[i]`，注意背包的容量也要减。

所以递推公式就是：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])`

初始化。

当背包容量为0时，所有物品都放不下，所以`dp[i][0]`都为0。

然后初始化`dp[1][j]`，根据`weight[0]`来判断`dp[0][j]`是多少

遍历顺序。

第一层for循环遍历物品，第二层for循环遍历背包容量。

vs

第一层for循环遍历背包容量，第二层for循环遍历物品。

这两个都是一样的，因为`dp[i][j]`来源于`dp[i-1][j]`（正上方）和`dp[i-1][j-weight[i]]`（左上方），所以只要保证这两个地方有值，就能推导出来。

---
上面都是二维dp数组，也可以用一维dp滚动数组来用

因为`dp[i][j]`的来源是上一层，所以可以看作把上一层拷贝下来，再在本层进行替换

简化为`dp[j]`，含义是：容量为`j`的背包所含物品最大价值为`dp[j]`

递推公式为`dp[j] = max(dp[j], dp[j-weight[i]] + value[i])`

初始化：`dp[0]=0`，其他的只要初始化成非负数就行了，即`dp[j] = 0`

遍历的时候，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且**内层for循环倒序遍历**！

因为新一层的数据是拷贝上一层的数据，如果是正序遍历的话，用的数据就是从左边来的新算出来的数据，而不是上一层的旧数据了。

### 416. 分割等和子集 (canPartition)

用一维dp数组

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n)$，虽然dp数组大小为一个常数，但是大常数

### 1049.最后一块石头的重量II (lastStoneWeightII)

和上一道题相同，可以看作其实是尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。

一堆的石头重量是sum，那么我们就尽可能拼成 重量为 sum / 2 的石头堆。 这样剩下的石头堆也是 尽可能接近 sum/2 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以 装满 最大重量为 sum / 2的背包。

- 时间复杂度：$O(m × n)$ , m是石头总重量（准确的说是总重量的一半），n为石头块数
- 空间复杂度：$O(m)$

### 494.目标和 (findTargetSumWays_BACKTRACK)

这道题也是把数分成两个集合，加法一个集合，减法一个集合。

本题要如何使表达式结果为target，

既然为target，那么就一定有 left组合 - right组合 = target。

left + right = sum，而sum是固定的。right = sum - left

left - (sum - left) = target 推导出 left = (target + sum)/2 。

target是固定的，sum是固定的，left就可以求出来。

此时问题就是在集合nums中找出和为left的组合。

### 474.一和零 (findMaxForm)

涉及到m和n两个参数，所以一维dp数组满足不了了。

## 完全背包问题


