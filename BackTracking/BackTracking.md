# 基础知识

回溯算法适用于以下题型：

* 组合问题：N个数里面按一定规则找出k个数的集合
* 切割问题：一个字符串按一定规则有几种切割方式
* 子集问题：一个N个数的集合里有多少符合条件的子集
* 排列问题：N个数按一定规则全排列，有几种排列方式
* 棋盘问题：N皇后，解数独等等

## 回溯算法模板

### 1. 回溯函数模板返回值以及参数

回溯算法中函数返回值一般为`void`。

因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

### 2. 回溯函数终止条件

一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

伪代码：
```
if(终止条件){
    存放结果;
    return;
}
```

### 3. 回溯搜索的遍历过程

![img.png](回溯搜索的遍历过程.png)

（图中特意举例集合大小和孩子的数量是相等的）

```
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

# 77. 组合 (combine)

回溯算法的经典题目

![img.png](combine.png)

可以看出，n决定了树的宽度，k决定了树的深度。

开始回溯三部曲：

1. 递归函数的返回值以及参数

在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。

此外，还需要一个`startIndex`，用来记录本层递归的中，集合从哪里开始遍历，防止出现重复的组合。

比如，从`[1,2,3,4]`中挑选出1后，下一个要从`[2,3,4]`中进行挑选了。

2. 回溯函数终止条件

什么时候到达所谓的叶子节点了呢？

path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。

此时用result二维数组，把path保存起来，并终止本层递归。

3. 单层搜索的过程

backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。

backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。

这道题还可以优化。

如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了。

# 216.组合总和III (combinationSum3)

注意回溯的时候，sum也要减去i

# 17.电话号码的字母组合 (letterCombinations)





