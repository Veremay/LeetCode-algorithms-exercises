# 基础知识

## 二叉树的种类

### 满二叉树

如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

![img.png](满二叉树.png)

这棵二叉树为满二叉树，也可以说深度为k，有$2^{k-1}$个节点的二叉树。


### 完全二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 $1$~ $2^{h-1}$ 个节点。

![img.png](完全二叉树.png)

### 二叉搜索树

二叉搜索树是一个有序树。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

![img.png](二叉搜索树.png)

### 平衡二叉搜索树

又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![img.png](平衡二叉搜索树.png)

## 二叉树的存储方式

可以**链式存储**，也可以**顺序存储**。

链式存储方式就用指针， 顺序存储的方式就是用数组。

| 链式存储                 | 顺序存储                 |
|----------------------|----------------------|
| 指针                   | 数组                   |
| ![img.png](链式存储.png) | ![img.png](顺序存储.png) |

其中，顺序存储中，父节点的数组下标是 i，那么它的左孩子就是 $i * 2 + 1$，右孩子就是 $i * 2 + 2$。

## 二叉树的遍历方式

**深度优先遍历**：先往深走，遇到叶子节点再往回走。

- 前序遍历（递归法，迭代法）
- 中序遍历（递归法，迭代法）
- 后序遍历（递归法，迭代法）

这里前中后，其实指的就是**中间节点**的遍历顺序

![img.png](深度优先遍历.png)

**广度优先遍历**：一层一层的去遍历。

- 层次遍历（迭代法）

## 二叉树的定义

```java

public class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode(){}
    TreeNode(int val){this.val = val;}
    TreeNode(int val, TreeNode left, TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```python
class TreeNode:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

# 递归遍历

递归算法的三个要素：

- 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

- 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

- 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

## 589.N叉树的前序遍历

思路是一样的，就是要加一个判断

```java
if(root.childen != null){
    for(Node child: root.childen){
        preorder(child,result);
    }
}

```

# 层序遍历

其实就是图论里的广度优先遍历

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑**，而用**栈先进后出适合模拟深度优先遍历也就是递归的逻辑**。

![102二叉树的层序遍历.gif](102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif)

步骤：
1. 将根节点入队
2. 当队列不为空时：
   1. 处理当前层的所有节点
   2. 将下一层的所有节点入队

## 199.二叉树的右视图

层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。

![img.png](二叉树的右视图.png)

## 637.二叉树的层平均值

本题就是层序遍历的时候把一层求个总和再取一个均值。

## 515.在每个树行中找最大值

## 116.填充每个节点的下一个右侧节点指针 & 117.

依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了

## 104.二叉树的最大深度 & 111.二叉树的最小深度

使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。

当要求二叉树的最小深度时，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点。

# 226.翻转二叉树

注意！交换的是指针，而不是数值

其实就是把每个节点的两个子节点进行交换。

我用的是层序遍历，用前序和后序遍历也可以做，中序遍历要麻烦一点，某些节点的左右孩子会翻转两次，要特殊处理一下。

# 101. 对称二叉树

首先想清楚，**判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点**！

其实我们**要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

## 递归

![img.png](对称二叉树.png)

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。

但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行。

## 递归法

递归三部曲

1. 确定递归函数的参数和返回值

因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以**要比较的是两个树，参数自然也是左子树节点和右子树节点**。

返回值自然是bool类型。

2. 确定终止条件

要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

节点为空的情况有：（注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点）

- 左节点为空，右节点不为空，不对称，return false
- 左不为空，右为空，不对称 return false
- 左右都为空，对称，返回true

- 此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空： 左右都不为空，比较节点数值，不相同就return false

此时左右节点不为空，且数值也不相同的情况我们也处理了。

3. 确定单层递归的逻辑

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。


# 110.平衡二叉树

**深度：从根节点开始，自上而下测量。**

**高度：从叶子节点开始，自下而上测量。**

这道题要求高度，所以采用后序遍历比较好。

仍然可以使用递归法和迭代法两种。

1. 明确递归函数的参数和返回值

参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。

那么如何标记左右子树是否差值大于1呢？

如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。

所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。

2. 明确终止条件

递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0。

3. 明确单层递归的逻辑

如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。

# 257. 二叉树的所有路径

要返回从根节点到所有叶子节点（即没有左右孩子节点的节点）的所有路径

![img.png](二叉树的所有路径.png)

递归法
1. 递归函数参数以及返回值

要传入根节点、存放每一条路径的列表、存放结果的列表，这里不需要返回值

2. 确定递归终止条件

在写递归的时候都习惯了这么写：
```
if (cur == NULL) {
   终止处理逻辑
}
```

但是本题的终止条件这样写会很麻烦，因为本题要**找到叶子节点，就开始结束的处理逻辑了**（把路径放进result里）。

那么什么时候算是找到了叶子节点？ 是**当 cur不为空，其左右孩子都为空的时候，就找到叶子节点**。

所以本题的终止条件是：
```
if (cur->left == NULL && cur->right == NULL) {
   终止处理逻辑
}
```

为什么没有判断cur是否为空呢，因为递归的逻辑可以控制空节点不入循环。

3. 确定单层递归逻辑

因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。

然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。

所以递归前要加上判断语句，下面要递归的节点是否为空。

递归完，要做回溯啊，因为path不能一直加入节点，它还要删节点，然后才能加入新的节点。

**回溯和递归是一一对应的，有一个递归，就要有一个回溯，所以回溯要和递归永远在一起**。

# 404.左叶子之和

首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。

节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点

判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。因为在左孩子节点自身，它无法知道自己是左孩子还是右孩子。

可以用层序遍历，也可以用递归。

# 513.找树左下角的值

用层序遍历最简单，就是记录最后一行的第一个元素

