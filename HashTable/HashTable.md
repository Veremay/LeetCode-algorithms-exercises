# 哈希表理论基础


# 15.三数之和

>给你一个整数数组 nums ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 0 且不重复的三元组。\
>注意：答案中不可以包含重复的三元组。

## 哈希表解法


## 双指针解法

先进行排序

然后

![15.三数之和.gif](15.三数之和.gif)

如果`nums[i] + nums[left] + nums[right] > 0` 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。

如果 `nums[i] + nums[left] + nums[right] < 0` 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

注意去重！

**a的去重**

说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 `nums[i]`，`nums[left]`，`nums[right]`

a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。

但这里有一个问题，是判断 `nums[i]` 与 `nums[i + 1]`是否相同，还是判断 `nums[i]` 与 `nums[i-1]` 是否相同。

如果我们的写法是 这样：
```
if (nums[i] == nums[i + 1]) { // 去重操作
    continue;
}
```
那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，但left指针指到的也是下一个-1，那这组数据就pass了。

我们要做的是 **不能有重复的三元组，但三元组内的元素是可以重复的**！

所以这里是有两个重复的维度。

那么应该这么写：
```
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
```

时间复杂度：$O(n^2)$

# 18.四数之和

和15.三数之和是一个思路，都是使用双指针法, 基本解法就是在15.三数之和的基础上再套一层for循环。

但是有一些细节需要注意，例如： 不要判断`nums[k] > target` 就返回了，三数之和 可以通过` nums[i] > 0` 就返回了，因为 0 已经是确定的数了，四数之和这道题目 `target`是任意值。比如：数组是`[-4, -3, -2, -1]`，`target`是-10，不能因为-4 > -10而跳过。

但是我们依旧可以去做剪枝，逻辑变成`nums[k] > target && (nums[k] >=0 || target >= 0)`就可以了。

15.三数之和的双指针解法是一层for循环`num[i]`为确定值，然后循环内有left和right下标作为双指针，找到`nums[i] + nums[left] + nums[right] == 0`。

四数之和的双指针解法是两层for循环`nums[k] + nums[i]`为确定值，依然是循环内有left和right下标作为双指针，找出`nums[k] + nums[i] + nums[left] + nums[right] == target`的情况。

三数之和的时间复杂度是$O(n^2)$，四数之和的时间复杂度是$O(n^3)$ 。

那么一样的道理，五数之和、六数之和等等都采用这种解法。